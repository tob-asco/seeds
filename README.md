# seeds - Humanity's Database of Creativity
## TODOs
- [ ] change id datatype to GUID
## Solution Structure
**seeds** (solution)
- **seeds.Api** (the web API project)
  - **Controllers**
    (almost no changes made w.r.t. the scaffolded controllers)
  - **Data** (DB access stuff)
  - **Helpers**
  - **Migrations** (auto-generated by *$ dotnet ef migrations add my_migration*)
  - `Program.cs` (the server startup class)
- **seeds.Dal** (the Data Access Layer project)
  - **Dto** (Data Transfer Objects - slightly different to the Model classes)
    - **ToApi** (DTOs that can be passed **to** the API)
  - **Interfaces** (of the services)
  - **Model** (the EF Core models)
  - **Services**
    - `DalBaseService.cs` (injected into each DAL Service class)
      - provides a *public* HttpClientWrapper* property (bc. it is injected, not inherited from)
      - provides generic methods for *GET*,*PUT*,*POST* methods of DAL Service classes (:exclamation: *GET* returns default(T) on NotFound HttpResponse, otherwise throws)
    - e.g. `UsersService.cs`
  - **Wrappers** (wrappers of static methods to enable testing)
- **seeds1** (the .NET MAUI frontend project)
  - **Converter** (classes used by the views)
  - **MauiModels** (models only used by the frontend project)
  - **Services**
  - **View** (the .xaml files plus their .xaml.cs "*code-behind*"s)
  - **ViewModel**
  - `App.xaml` (global view resources, e.g. styles)
  - `AppShell.xaml` (definition of the navigating Shell)
  - `MauiProgram.cs` (the MAUI startup class)
 
## Tests Structure
**seeds** (solution)
- **seeds.Api.Tests** (xUnit test project of the Web API)
  - **Controllers**: No Unit tests, only endpoint tests
    - `ApiBaseControllerTests.cs` (provides unpopulated _context and an _httpClient accessing it, through the `ProgramTest.cs` in-memory server)
    - *GET*
      1. `ControllerName_GetEndpoint_ReturnsItself()`
      2. `ControllerName_GetEndpoint_IfNotExistReturnsNotFound()`
    - *PUT*
      1. `ControllerName_PutEndpoint_ReturnsSuccessAndUpdatedDb()` (i.e. update the context)
      2. `ControllerName_PutEndpoint_IfNotExistReturnsNotFound()`
      3. if `MyModelFromDb` and hence an AutoMapper map exists: `ControllerName_PutEndpoint_LeavesSomeProperty()` to ensure that AutoMapper doesn't update provided values
    - *POST*
      1. `ControllerName_PostEndpoint_ReturnsSuccessAndUpdatedDb()` (i.e. update the context)
      2. `ControllerName_PostEndpoint_IfExistReturnsConflict()`
      3. if `MyModelToDb` exists: `ControllerName_PostEndpoint_ReturnsUpdatedPk()` to ensure that we recieve the model as is in the DB from POST
    - e.g. `UserControllerTests.cs`
  - `ProgramTest.cs` (the test server startup class)
- **seeds.Dal.Tests** (xUnit test project of the DAL units)
  - **Services**: Unit tests
    - *GET*
      1. `ServiceName_GetModelAsync_ReturnsItself()`
      2. `ServiceName_GetModelAsync_IfNotExistReturnsNull()`
    - *PUT* (depending on whether a PUT must succeed or can fail, e.g. if the PK need not exist)
      1. `ServiceName_PutModelAsync_ReturnsTrue()` or `ServiceName_PutModelAsync_Returns()`
      2. `ServiceName_PutModelAsync_IfNotSuccessReturnsFalse()` or `ServiceName_PutModelAsync_IfNotSuccessThrows()`
    - *POST*
      1. `ServiceName_PostModelAsync_ReturnsTrue()` or ... (cf. PUT)
      2. `ServiceName_PostModelAsync_IfNotSuccessReturnsFalse()` or ... (cf. PUT)
    - e.g. `UsersServiceTests.cs`
    - `DalBaseServiceTests.cs` (generic unit tests)
      - tests that `default(T)` w/ `T` a Model gives `null`
      - distinguishes `HttpStatusCode.NotFound` and other bad responses in *GET* (for the cases where `default(T)` is not a clear sign of error, e.g. `T = typeof(int)`)
- **seeds1.Tests** (xUnit test project of the MAUI App)
  - **ViewModel**: Unit tests. Tests include
    - *Raise Property Changed Event* (PCE) - tests
    - *Navigates to* - tests (using mocked navigation services)

## Error Handling Philosophy
Trying to streamline the throwing & try-catching procedure of exceptions throughout the solution:
1. The first method that is sure that a certain response indicates an error, is the one that needs to `throw new Exception("A message providing all the info");`.
2. The method closest to the view (e.g. directly called by a command in a VM) needs to `try`-`catch (Exception ex)` and `await Shell.Current.DisplayAlert(...);`

## What You Should Do When...
### **You want to add a new EF Core model class that defines a seperate entity** (not a join entity)
  1. Add an EF Core model class `seeds.Dal.Model.MyModel.cs`
     - the class should be singular and CamelCase, the table should be plural and sql_case
     - the columns should be singular and sql_case
  3. Add a DTO Model `MyModelDto.cs` somewhere appropriate in `seeds.Dal.Dto`
  4. Create the corresponding AutoMapper mappings in `seeds.Api.Helpers.AutoMapperProfiles.cs`
  5. Add a configuration class `seeds.Api.Data.MyModelConfiguration.cs` and call it in `seedsApiContext.cs`
  6. Scaffold out a controller by right-clicking `seeds.Api.Controllers` :arrow_right: Add API Controller with actions, using EF :arrow_right: choose `MyModel` as model and the existing context class and hence create `seeds.Api.Controllers.MyModelsController.cs`
  7. Adapt the `MyModelsController` class to return not the EF model, but the DTO model; delete useless endpoints
  8. Create an interface `seeds.Dal.Interfaces.IMyModelService.cs`
  9. Implement it in a service class `seeds.Dal.Services.MyModelService.cs` that accesses the endpoints
  10. Register the last two points to the DI container
  11. Use the model in the VMs *a little bit* (to see whether it actually suits your needs) and then write tests `seeds.Api.Tests.Controllers.MyModelsControllerTests.cs` and `seeds.Dal.Tests.Services.MyModelServiceTests.cs`
### **You add a new join entity EF Core model class**
  1. Add an EF Core model class `seeds.Dal.Model.MyJoinEntity.cs`
     - the class should be singular and CamelCase, the table should be plural and sql_case
     - the columns should be singular and sql_case
     - contains 2 foreign keys
     - probably contains payload
  3. Add a configuration class `seeds.Api.Data.MyJoinEntityConfiguration.cs`
     - probably needs to define its primary key as a combination of the two FKs like `builder.HasKey(je => new {je.FK1, je.FK2});`
  4. Scaffold out a controller by right-clicking `seeds.Api.Controllers` :arrow_right: Add API Controller with actions, using EF :arrow_right: choose `MyJoinEntity` as model and the existing context class and hence create `seeds.Api.Controllers.MyJoinEntitiesController.cs`
  5. Minimally adapt the `MyJoinEntitiesController` class, e.g. delete useless endpoints
  6. Create an interface `seeds.Dal.Interfaces.IMyJoinEntityService.cs`
  7. Implement it in a service class `seeds.Dal.Services.MyJoinEntityService.cs` that accesses the endpoints
  8. Register the last two points to the DI container
  9. Use the model in the VMs *a little bit* (to see whether it actually suits your needs) and then write tests `seeds.Api.Tests.Controllers.MyJoinEntitiesControllerTests.cs` and `seeds.Dal.Tests.Services.MyJoinEntityServiceTests.cs`
